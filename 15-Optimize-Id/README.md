Currently our implementation for Id will always copy the value to be bound and store the copy in the identifier.
What about those values that cannot be copied, such as std::unique_ptr, std::mutex, or reference to abstract class?
Then can we always store the pointer instead of storing the value?
Maybe not. There are temporary values generated by some transformers, remeber the `app` patterns?
Can we move instead of copying values?
Hmmm, users may not expect their std::unique_ptr values become empty after matching some patterns.
We should not modified users' data implicitly.

The conclusion is that we need to store the value sometimes and store the pointer some other times.
But there are some improvement space for storing the value. Instead of always copying, we can call move constructor when accepting temporary values.  For better performance for Id, we need to use forward reference as possible, and always forward for the last uses of the values.
But we would like to leave that to a later improvement.

For now, we will make `identifier` pattern work functionally for all kinds of values.
Storing values or pointers depends on whether the values to be bound are temporary.
Since storing values or pointers is a compile-time decision, we need different type or compile time flag to indicate this.
(Not exactly, we can always store pointers, but use a flag to indicate whether the memory is owned by the Id object. Will explore if we can unify this and detect the flag at runtime during binding later.)

We decide to introduce a non-type template parameter `bool own` for this purpose.
When `own = true`, we store values. Otherwise we store pointers.
(Alternatively, users can choose to use a runtime boolean flag own.)

We default `own` to true, i.e., `id<int32_t>` is equal to `id<int32_t, true>`.
For better user experience, we add an alias `RefId` for `own = false`.

The behavior of storing values or pointers (references) can be implemented with ownership.
Storing values means allocating a memory block and construct a new object via copying the value.
Releasing the resources inside destructors.
Storing pointers (references) means assigning the pointer to the address of the value memory.
Instead of managing memory ourselves, let's use the `std::unique_ptr` from STL.
We can define different deleters for owned and non-owned memory.
```C++
class NoDelete
{
public:
    void operator()(Type const*){}
};
using PtrT = std::conditional_t<own, std::unique_ptr<Type const>, std::unique_ptr<Type const, NoDelete>>;
```

Note that Deleter type is part of the `std::unique_ptr` type, which is different from `std::shared_ptr`. And you cannot change the deleter type at runtime. (You can change the deleter if the new deleter shares the same type with the old via get_deleter();)
`std::shared_ptr` can be used with runtime flag for ownership. Deleters and deleter types can be changed when reassign to `std::shared_ptr` due to the type erasure technique used by `std::shared_ptr`.

Inside `Id::matchValue`, the codes for binding a new value looks like
```C++
if constexpr (own)
{
    *mValue = std::make_unique<Value>(value);
}
else if constexpr (!own)
{
    (*mValue).reset(&value);
}
```
with a `std::unique_ptr` backend.
And it looks like
```C++
if (mOwn)
{
    *mValue = std::make_shared<Value>(value);
}
else
{
    (*mValue).reset(&value, [](auto&&){});
}
```
with a `std::shared_ptr` backend.

The `std::unique_ptr` is better for performance and is adopted from this section.

Now users can bind to `std::unique_ptr` via `RefId`:
```C++
RefId<std::unique_ptr<int32_t>> i;
match(x)(
    pattern(i).when([&i]{return *i && **i == 5;}) = [] { return 1; },
    pattern(_)                                    = [] { return 2; }
);
```